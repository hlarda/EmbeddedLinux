# INTRODUCTION

## Why Linux?

- Free
- Open source
- Portable
- Excellent network support
- Security features
- Supports many architectures
- Community support

## Embedded Linux

A customized version of Linux for embedded target devices. Tools used include YOCTO and the toolchain.

## Main Components to Build Linux System

- **Toolchain**:
    Includes the compiler, linker, assembler, etc. Used to build the software for the target architecture.
- **Bootloader**:
    Examples include u-boot, grub, etc. Used to load the kernel and initramfs into memory.
- **Kernel**:
    Manages the hardware and provides the system calls.
- **Rootfs**:
    Provides the basic utilities and libraries for the system such as shell, ls, cp, etc. Examples include busybox.

## What is kconfig?

Kconfig is a configuration system used by the Linux kernel to manage the configuration options. It provides a menu-driven interface (terminal user interface) to configure the kernel options. It generates the `.config` file which is used by the kernel build system to build the kernel.

## SD Card Structure

The SD card contains two main folders which hold the main components to build a Linux system (excluding the toolchain):

- **boot**:
    Contains the kernel build (device tree, MLO, zImage) and uboot (u-boot.img, extlinux).
- **root**:
    Generated by tools like busybox. Contains directories like bin, dev, etc, home, lib, mnt, proc, sbin, sys, tmp, usr, var.

## Booting Sequence

### EEPROM bootloader

- **BIOS/UEFI** (1st stage bootloader)
    1. Initialize HW drivers
    2. Check HW functionality
    3. Check for portable devices
    4. Check if there is a short circuit

### HDD

- **BIOS/UEFI**
  - loads 512 bytes located in HDD (MBR/GPT) into RAM (2nd stage bootloader)
  - Contains partition table
  - Gives control to the 2nd stage bootloader
- **MBR/GPT**
  - loads 3rd stage bootloader (Grub).
  - (Grub) which located in HDD after MBR/GPT code, into RAM
    1. Select between OSs
    2. Loads kernel
- **Kernel**
    1. loads device drivers
    2. initializes RAM
    3. runs init process
    4. manages usr processes

    ```bash
    ps -aux | grep k
    ```

- **iniRamfs( initial ram file system) allocated in HDD loaded by kernel**
    1. not mandatory for some systems
    2. if it does not exist, kernel will mount rootfs directly
    3. it is an initial root file system that is mounted before the real root file system is available
    4. it contains the necessary executables and libraries to mount the real root file system
    5. it is used to perform tasks such as loading kernel modules, setting up device nodes, and mounting the real root file system

## Difference Between UEFI and BIOS

- ### BIOS (Basic Input/Output System)

  - windows blue screen
  - no animation
  - cant recognize ethernet, wifi or bluetooth
  - no mouse support or touchpas, only keyboard
  - no sequre booting options
  - the firmware program written in 16-bit assembly language
  - supports drive till 2.2 terabytes
  - based on MBR

- ### UEFI (Unified Extensible Firmware Interface)

  - user friendly graphical user interface
  - multi color with animation
  - supports ethernet, wifi and bluetooth connectivity
  - supports mouse and touchpad
  - supports secure booting options
  - the firmware program written in C language
  - supports drive till 9 zettabytes
  - based on GPT
  
**to Recognize Which One is Used in Your System**
If the `?fi` folder is present then UEFI is used.

  ```bash
  ls /sys/firmware/
  the output is:
  acpi  dmi  efi  memmap
  ```

**to get BIOS information:**

  ```bash
  sudo dmidecode -t bios
  ```

## what is MBR and GPT?

MBR (Master Boot Record) and GPT (GUID Partition Table) are two different ways of storing the partitioning information on a drive.

This information includes where partitions start and end,so your operating system knows which sectors belong to each partition and which partition is bootable.

- ### MBR
  
    1. MBR is the older standard for managing partitions.
    2. It's used by DOS, Windows, and Unix-like operating systems.
    3. MBR allows up to four primary partitions, and if you want more,you need to make one of them an "extended partition" which can host additional "logical" partitions.
    4. MBR also has a limit of 2TB for partition sizes.

- ### GPT

    1. GPT is a newer standard that's part of the UEFI specification.
    2. It doesn't have the same limitations as MBR.
    3. You can have up to 128 primary partitions, and there's no 2TB size limit.
    4. GPT also includes better error handling and recovery tools than MBR as it stores multiple copies of the partition table throughout the disk.

    In general, for newer systems, especially those using UEFI, GPT is the recommended choice.
    For older systems, particularly those using BIOS, MBR may still be used.

## GRUB?

GRUB (GRand Unified Bootloader) is a multibo bootloader. It was developed by the GNU Project and is the most commonly used bootloader among Unix and Unix-like operating systems.

GRUB is responsible for loading and transferring control to the operating system kernel software. The kernel, in turn, initializes the rest of the operating system.

One of the key features of GRUB is that it has a command-line interface which allows users to dynamically select which operating system or kernel to boot to.

This is especially useful in systems that have multiple operating systems installed.

It also supports a variety of filesystems, allowing it to load kernels from nearly any location, including network sources.

## Mount?

Mounting is the process of making a filesystem available to the operating system. This allows the user to access the files and directories stored on the filesystem.

When a filesystem is mounted, the operating system reads the filesystem's structure and metadata, and makes it available to the user through a mount point, which is a directory in the system's directory tree.

The mount command is used to mount filesystems in Unix-like operating systems.
It takes the device or filesystem to be mounted, the mount point, and the filesystem type as arguments.
For example, to mount a USB drive with the device name /dev/sdb1 to the mount point /mnt/usb,
you would use the following command:

  ```bash
    sudo mount /dev/sdb1 /mnt/usb
  ```

After mounting the filesystem, the files and directories on the device will be accessible through the /mnt/usb directory.

To unmount a filesystem, you can use the umount command.
For example, to unmount the USB drive mounted at /mnt/usb, you would use the following command:

  ```bash
  sudo umount /mnt/usb
  ```

After unmounting the filesystem, the device will no longer be accessible through the mount point.

## Init process?

1. the first process started by the Linux kernel when the system boots.
2. has a process ID (PID) of 1, and is the parent of all other processes on the system.

  ```bash
  $ pstree
    systemd─┬─ModemManager───2*[{ModemManager}]
            ├─NetworkManager───2*[{NetworkManager}]
            ├─accounts-daemon───2*[{accounts-daemon}]
            ├─acpid
            ├─agetty
            .....................
  $ ps -aux | grep init
            PID
    root  1  0.0  0.1 166404 11328 ? Ss   Apr28   0:01 sbin/init sp
  ```

## difference between transient process and daemon process

Processes in a Unix-like operating system can be broadly categorized into two types: transient and daemon.
  **1. Transient processes:**
    These are typically command-line utilities like `ls` When you run a command like `ls`, the shell starts a new process to execute the command.

The `ls` process does its job, sends its output to the shell, and then terminates. These processes do their work quickly and don't stay around.

   **2. Daemon processes:**
    These are background services that start at boot time  and keep running as long as the system is up. They provide various services that the system needs to function properly. The `init` process is a special case of a daemon process. It's the first process that the kernel starts, and it's responsible for starting all other processes.

The `init` process always has a process ID (PID) of 1 and it continues to run until the system is shut down as its code has while(1) loop.

  ```bash
    $ ps -aux | grep ls
        "there is no ls process as it is a transient process"
    
    $ sleep 1000 &
    [1] 28716
    
    $ ps -aux | grep 28716
    hala       28716  0.0  0.0   8376  1028 pts/0    S    06:41   0:00 sleep 1000
    hala       29392  0.0  0.0   9216  2436 pts/0    S+   06:42   0:00 grep --color=auto 28716
  ```

## systemd VS systemV

postponed

## GUI

"GUI is a server app" means that the graphical interface is served by a process called the X server.

The X server is responsible for managing graphical elements.
It acts as a server because it provides services to other programs, such as applications that need to display graphical elements on the screen.

- **Client-Server Architecture:**
        The X Window System follows a client-server architecture model.
        In this model, the graphical applications (clients) communicate with a central component known as the X server.
        The X server manages the display hardware and handles user input devices like the keyboard and mouse.
- **X Server:**
        The X server is the core component of the X Window System.
        It's responsible for coordinating communication between clients and the display hardware.
        The server interacts directly with the graphics hardware and controls the display screen.
    **Graphics Rendering:**
        When a client application needs to draw something on the screen,
        it sends drawing commands to the X server.
        The server then performs the necessary rendering operations,
        such as drawing lines, text, or images, on behalf of the client.
        This separation of rendering tasks allows multiple applications to share the same display without interfering with each other.
